module BinRemNode

use int.Int
use binTree.Tree
use binTree.Occ
use binTree.Size
use option.Option

predicate binsearch (t:tree int) =
match t with 
|Empty -> true
|Node a b c -> (forall i: int. mem i a -> i<=b) /\ (forall j: int. mem j c -> j > b)
                /\ binsearch a /\ binsearch c
end

predicate is_minimum (x: int) (t: tree int) =
  mem x t /\ forall e. mem e t -> x <= e
  

let rec function min (t: tree int) : int 
    variant{t}
    requires{t <> Empty /\ binsearch t}
    ensures {is_minimum result t}
    = match t with
    | Empty -> absurd
    | Node Empty a _ -> a
    | Node l a _ -> min l
    end


(*lemma is_minimum_min: forall t. binsearch t /\ t<> Empty -> is_minimum (min t) t*)

(*let rec find_min (t: tree int): (x: int, y: tree int)
variant {t}
requires {binsearch t /\ t <> Empty /\ forall j: int. occ j t <= 1}
ensures {(*forall i : int. mem i t -> i >= x /\ mem x t /\ binsearch y 
        /\ (forall j : int. mem j t /\ j <> x -> mem j y) 
        /\ (forall z : int. mem z y -> mem z t) /\ not mem x y /\*)
        x = min t}
= match t with
| Empty -> absurd
| Node Empty x r -> (x, r)
| Node l a b -> let x,y = find_min l in (x, (Node y a b))
end*)

let rec delete (t: tree int) (x:int): (tree int)
requires {binsearch t /\ forall j: int. occ j t <= 1}
variant {t}
ensures {(forall j : int. mem j t /\ j <> x -> mem j result) 
        /\ (forall i:int. mem i result -> mem i t) /\ not mem x result 
        /\ binsearch result}
= 
match t with 
| Empty -> Empty
| Node l y r ->  if x < y then Node (delete l x) y r else 
                if x > y then Node l y (delete r x) else
                match l, r with
                |Empty, _ -> r
                |_, Empty -> l
                |l', r' -> let mini = min r' in Node l' mini (delete r' mini)
               end 
end
end


 

