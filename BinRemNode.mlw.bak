module BinRemNode

use int.Int
use binTree.Tree
use binTree.Occ
use binTree.Size
use option.Option

predicate binsearch (t:tree int) =
match t with 
|Empty -> true
|Node a b c -> (forall i: int. mem i a -> i<=b) /\ (forall j: int. mem j c -> j > b)
                /\ binsearch a /\ binsearch c
end

let rec function minimum (t: tree int) : int 
    variant{t}
    requires{t <> Empty /\ binsearch t}
    ensures {forall i:int. mem i t -> result <= i}
    = match t with
    | Empty -> absurd
    | Node l a _ -> minimum l
    | Node Empty a _ -> a
    end

let rec find_min (t: tree int): (x: int, y: tree int)
variant {t}
requires {binsearch t /\ t <> Empty /\ forall j: int. occ j t <= 1}
ensures {(forall i : int. mem i t -> i >= x) /\ mem x t /\ binsearch y 
        /\ (forall j : int. mem j t /\ j <> x -> mem j y) 
        /\ (forall z : int. mem z y -> mem z t) /\ not mem x y 
       }
= match t with
| Empty -> absurd
| Node Empty x r -> (x, r)
| Node l a b -> let x,y = find_min l in (x, (Node y a b))
end

let rec delete (t: tree int) (x:int): (tree int)
requires {binsearch t /\ forall j: int. occ j t <= 1}
variant {t}
ensures {(forall j : int. mem j t /\ j <> x -> mem j result) 
        /\ (forall i:int. mem i result -> mem i t) /\ not mem x result 
        /\ binsearch result}
= 
match t with 
| Empty -> Empty
| Node l y r ->  if x < y then Node (delete l x) y r else 
                if x > y then Node l y (delete r x) else
                match l, r with
                |Empty, _ -> r
                |_, Empty -> l
                |l', r' -> let min, y = find_min r' in Node l' min y
               end 
end
end


 

